autopilot.f90:! this program; if not, write to the 
autopilot.f90:          IF( ionode ) write(*,*) ' AutoPilot: current input_line', input_line 
autopilot.f90:             IF( ionode ) write(*,*) ' AutoPilot: current input_line', input_line 
autopilot.f90:       IF( ionode ) write(*,*) 'ADD_RULE: POWER STEERING'
autopilot.f90:          IF( ionode ) write(*,*) ' AutoPilot: current input_line', input_line 
autopilot.f90:             IF( ionode ) write(*,*) ' AutoPilot: current input_line', input_line
autopilot.f90:       IF( ionode ) write(*,*) ' AutoPilot: current n_rules', n_rules
autopilot.f90:    !IF( ionode ) write(*,*) '  Number of rules: ', n_rules
autopilot.f90:    IF( ionode ) write(*,'("   Reading rule: ",A20,A20)' ) var, value
autopilot.f90:       !IF( ionode ) write(*,*) 'RULE_DT', rule_dt(event), 'EVENT', event
autopilot.f90:       IF( ionode ) write(*,*) '  Autopilot: Rule Assignment Failure '
autopilot.f90:       IF( ionode ) write(*,*) 'SLEEPING'
autopilot.f90:       IF( ionode ) write(*,*) 'INPUT_LINE=', input_line
autopilot.f90:       IF( ionode ) write(*,*) 'RUNNING'
autopilot.f90:       IF( ionode ) write(*,*) 'INPUT_LINE=', input_line
bfgs_module.f90:           write (*,'(3f15.10)') TRANSPOSE ( RESHAPE( grad(n-8:n), (/ 3, 3 /) ) )
bfgs_module.f90:           write (*,*)
bfgs_module.f90:           write (*,'(3f15.10)') TRANSPOSE(h)
bfgs_module.f90:           write (*,*)
bfgs_module.f90:           write (*,'(3f15.10)') MATMUL (TRANSPOSE( RESHAPE( grad(n-8:n), (/ 3, 3 /) ) ),&
bfgs_module.f90:           write (*,*)
bfgs_module.f90:           write (*,*) cell_error/cell_thr*0.5d0
bfgs_module.f90:        if(info .ne. 0)write( stdout, '(/,5X,"WARNING: info=",i3," for Hessian")' )info
bspline.f90:! - write to string instead of stdout
bspline.f90:!   License along with this library; if not, write to the
bspline.f90:     !!write(6,*) "subroutine dbsnak: "
bspline.f90:     !!write(6,*) "eps = ",eps
bspline.f90:     write(errmsg,*) "0 <= kxord <= nx is required: kxord,nx=", kxord, nx
bspline.f90:     write(errmsg,*) 'no solution of linear equation system'
bspline.f90:998 write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:        write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:     write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", x
bspline.f90:        write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:     write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", x
bspline.f90:        write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:       write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", xvec(ix)
bspline.f90:     write(errmsg,*) "no solution of linear equation system"
bspline.f90:998 write(errmsg,*) "i with knot(i) <= x/y < knot(i+1) required: knot(1),knot(n+k)=", &
bspline.f90:        write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:     write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", x
bspline.f90:        write(errmsg,*) "yknot(iy) <= yknot(iy+1) required: iy,yknot(iy),yknot(iy+1)=", &
bspline.f90:     write(errmsg,*) "iy with yknot(iy) <= y < yknot(iy+1) required: y=", y
bspline.f90:        write(errmsg,*) "xknot(ix) <= xknot(ix+1) required: ix,xknot(ix),xknot(ix+1)=", &
bspline.f90:     write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", x
bspline.f90:        write(errmsg,*) "yknot(iy) <= yknot(iy+1) required: iy,yknot(iy),yknot(iy+1)=", &
bspline.f90:     write(errmsg,*) "iy with yknot(iy) <= y < yknot(iy+1) required: y=", y
bspline.f90:        write(errmsg,*) "xknot(i) <= xknot(i+1) required: i,xknot(i),xknot(i+1)=", &
bspline.f90:        write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", xvec(i)
bspline.f90:        write(errmsg,*) "yknot(i) <= yknot(i+1) required: i,yknot(i),yknot(i+1)=", &
bspline.f90:        write(errmsg,*) "iy with yknot(iy) <= y < yknot(iy+1) required: y=", yvec(i)
bspline.f90:     write(errmsg,*) "no solution of linear equation system"
bspline.f90:998 write(errmsg,*) "i with knot(i) <= x/y/z < knot(i+1) required: xyzknot(1),xyzknot(n+k)=", &
bspline.f90:        write(errmsg,*) "zknot(iz) <= zknot(iz+1) required: iz,zknot(iz),zknot(iz+1)=", &
bspline.f90:     write(errmsg,*) "iz with zknot(iz) <= z < zknot(iz+1) required: zknot(iz),z,zknot(iz+1)=", &
bspline.f90:        write(errmsg,*) "zknot(iz) <= zknot(iz+1) required: iz,zknot(iz),zknot(iz+1)=", &
bspline.f90:     write(errmsg,*) "iz with zknot(iz) <= z < zknot(iz+1) required: zknot(iz),z,zknot(iz+1)=", &
bspline.f90:        write(errmsg,*) "xknot(i) <= xknot(i+1) required: i,xknot(i),xknot(i+1)=", &
bspline.f90:        write(errmsg,*) "ix with xknot(ix) <= x < xknot(ix+1) required: x=", xvec(i)
bspline.f90:        write(errmsg,*) "yknot(i) <= yknot(i+1) required: i,yknot(i),yknot(i+1)=", &
bspline.f90:        write(errmsg,*) "iy with yknot(iy) <= y < yknot(iy+1) required: y=", yvec(i)
bspline.f90:        write(errmsg,*) "zknot(i) <= zknot(i+1) required: i,zknot(i),zknot(i+1)=", &
bspline.f90:        write(errmsg,*) "iz with zknot(iz) <= z < zknot(iz+1) required: z=", zvec(i)
cell_base.f90:    !write(stdout,*) 'alat=',alat
cell_base.f90:    !write(stdout,*) 'at=',at
cell_base.f90:    !write(stdout,*) 'bg=',bg
constraints_module.f90:            write(stdout,*)'torsional angle constraint #',ia,' contains collinear atoms'
control_flags.f90:  LOGICAL :: trhow     = .FALSE. ! CP code, write rho to restart dir
control_flags.f90:  LOGICAL :: tksw      = .FALSE. ! CP: write Kohn-Sham states to restart dir
control_flags.f90:  INTEGER :: isave  = 0 ! write restart to ndr unit every isave step
coulomb_vcut.f90:    write(0,*) "AHIA",sum((matmul(inv,a)-eye3)**2)
coulomb_vcut.f90:    write(0,*) "A",a
coulomb_vcut.f90:    write(0,*) "inv",inv
coulomb_vcut.f90:    write(0,*)">>", matmul(inv,a)
date_and_tim.f90:  write (cdate,'(i2,a3,i4)') date_time(3), months(date_time(2)), date_time(1)
date_and_tim.f90:  write (ctime,'(i2,":",i2,":",i2)') date_time(5), date_time(6), date_time(7)
error_handler.f90:  ! ... Whenever possible (IBM SP machines), we write to the standard
error_handler.f90:  !  .. write the message to a file and close it before exiting
error_handler.f90:    write(unit=*,fmt=*) "   Called by ", routine_chain%routine_name
error_handler.f90:       write(unit=*,fmt=*) &
error_handler.f90:       write(unit=*,fmt=*) " "
error_handler.f90:       write(unit=*,fmt=*) " "
error_handler.f90:       write(unit=*,fmt=*) &
error_handler.f90:          write(unit=*,fmt=*) "   Fatal error in routine `", &
error_handler.f90:          write(unit=*,fmt=*) "   Warning from routine `", &
error_handler.f90:       write(unit=*,fmt=*) &
funct.f90:       write (stdout,*) iexch, save_iexch
funct.f90:       write (stdout,*) icorr, save_icorr
funct.f90:       write (stdout,*) igcx, save_igcx
funct.f90:       write (stdout,*) igcc, save_igcc
funct.f90:       write (stdout,*) inlc, save_meta
funct.f90:       write (stdout,*) inlc, save_inlc
funct.f90:           ! write(*, '("matches",i2,2X,A,2X,A)') i, name(i), trim(dft)
funct.f90:           write(*, '(2(2X,i2,2X,A))') i, trim(name(i)), &
funct.f90:     write (stdout,'(/,5x,a)') "IMPORTANT: XC functional enforced from input :"
funct.f90:     write (stdout,'(5x,a)') "Any further DFT definition will be discarded"
funct.f90:     write (stdout,'(5x,a/)') "Please, verify this is what you really want"
funct.f90:    write (stdout,'(/,5x,a)') "XC functional enforced to be EXXRPA"
funct.f90:    write (stdout,'(5x,a)') "!!! Any further DFT definition will be discarded"
funct.f90:    write (stdout,'(5x,a/)') "!!! Please, verify this is what you really want !"
funct.f90:    write (stdout,'(/,5x,a)') "Only exx_fraction is set to 1.d0"
funct.f90:    write (stdout,'(5x,a)') "XC functional still not changed"
funct.f90:     write (stdout,'(5x,a,f6.2)') 'EXX fraction changed: ',exx_fraction
funct.f90:     write (stdout,'(5x,a,f12.7)') 'EXX Screening parameter changed: ', &
funct.f90:     write (stdout,'(5x,a,f12.7)') 'EXX Gau parameter changed: ', &
funct.f90:        write (stdout,*) iexch, iexch_
funct.f90:        write (stdout,*) icorr, icorr_
funct.f90:        write (stdout,*) igcx, igcx_
funct.f90:        write (stdout,*) igcc, igcc_
funct.f90:        write (stdout,*) inlc, inlc_
funct.f90:  write(longname,'(4a5)') exc(iexch),corr(icorr),gradx(igcx),gradc(igcc)
functionals.f90:!        write(*,*) s, t1, t10, d1st1,d1rt1,d1rt10
gth.f90:  ! write(6, '(2f10.5,2x,i8,t47,a)' )  znucl,upf%zp,pspdat,'znucl, zion, pspdat'
gth.f90:  ! write(6, '(4i5,i10,f10.5,t47,a)' ) pspcod,pspxc,lmax,lloc,mmax,r2well,&
gth.f90:  ! write(6, '(a,f12.7)' ) ' rloc=',rloc
gth.f90:  ! write(6, '(a,i1,a,4f12.7)' ) ' cc(1:',nn,')=',(cc(jj),jj=1,nn)
gth.f90:    !   write(6, '(a,i3,a,f12.7,2a,3f12.7,2a,12x,2f12.7,2a,24x,f12.7)' )&
gth.f90:    !   write(6, '(a,3f12.7,2a,12x,2f12.7,2a,24x,f12.7)' )&
hdf5_qe.f90:  subroutine setup_file_property_hdf5(hdf5desc ,filename, hyperslab, write, kpoint)
hdf5_qe.f90:   logical,  intent(in) :: hyperslab, write
hdf5_qe.f90:   write(kstring,'(I0)') kpoint
hdf5_qe.f90:    if(write.eq..true.)then
hdf5_qe.f90:   write(kstring,'(I0)') kpoint
hdf5_qe.f90:   !INTEGER, ALLOCATABLE :: data (:,:)  ! Data to write
hdf5_qe.f90:   write(kstring,'(I0)') kpoint
hdf5_qe.f90:   write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:    write(dset_name,'(I0)') dsetname
hdf5_qe.f90:    write(dset_name,'(I0)') dsetname
hdf5_qe.f90:    write(kstring,'(I0)') kpoint
hdf5_qe.f90:    write(kstring,'(I0)') kpoint
hdf5_qe.f90:    write(kstring,'(I0)') kpoint
hdf5_qe.f90:    write(dset_name,'(I0)') dsetname
hdf5_qe.f90:    write(dset_name,'(I0)') dsetname
hdf5_qe.f90:    write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:  subroutine initialize_io_hdf5(hdf5desc,comm, data, write,kpoint)
hdf5_qe.f90:    logical, intent(in) :: write
hdf5_qe.f90:    write(mpimestring,'(I0)') mpime
hdf5_qe.f90:    if(write.eq..true.)then
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      !write(attrdata,'(I0)') attr_data
hdf5_qe.f90:      !write(attrdata,'(I0)') attr_data
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
hdf5_qe.f90:      write(kstring,'(I0)') kpoint
io_files.f90:  ! ... read/write nword words starting from the address specified by vect
io_files.f90:    ! input: the unit where to read/write
io_files.f90:    ! input: the record where to read/write
io_files.f90:   ! input/output: the vector to read/write
libxc.f90:!! along with this program; if not, write to the Free Software
mp_base.f90:        write(*,*) 'BCAST_REAL IN'
mp_base.f90:        write(*,*) 'BCAST_REAL OUT'
mp_base.f90:        write(*,*) 'BCAST_INTEGER IN'
mp_base.f90:        write(*,*) 'BCAST_INTEGER OUT'
mp_base.f90:        write(*,*) 'BCAST_LOGICAL IN'
mp_base.f90:        write(*,*) 'BCAST_LOGICAL OUT'
mp_base.f90:  write(*,*) 'reduce_base_real IN'
mp_base.f90:  write(*,*) 'reduce_base_real OUT'
mp_base.f90:  write(*,*) 'reduce_base_real IN'
mp_base.f90:  write(*,*) 'reduce_base_real OUT'
mp_base.f90:  write(*,*) 'reduce_base_integer IN'
mp_base.f90:  write(*,*) 'reduce_base_integer OUT'
mp_base.f90:  write(*,*) 'reduce_base_integer IN'
mp_base.f90:  write(*,*) 'reduce_base_integer OUT'
mp_base.f90:  write(*,*) 'reduce_base_real_to IN'
mp_base.f90:  write(*,*) 'reduce_base_real_to OUT'
mp_base.f90:  write(*,*) 'reduce_base_integer_to IN'
mp_base.f90:  write(*,*) 'reduce_base_integer_to OUT'
mp_base.f90:  write(*,*) 'parallel_min_integer IN'
mp_base.f90:  write(*,*) 'parallel_min_integer OUT'
mp_base.f90:  write(*,*) 'parallel_max_integer IN'
mp_base.f90:  write(*,*) 'parallel_max_integer OUT'
mp_base.f90:  write(*,*) 'parallel_min_real IN'
mp_base.f90:  write(*,*) 'parallel_min_real OUT'
mp_base.f90:  write(*,*) 'parallel_max_real IN'
mp_base.f90:  write(*,*) 'parallel_max_real OUT'
open_close_input_file.f90:  ! ...  otherwise, but ensure first that all processors can read and write!
plot_io.f90:  !     iflag >0 : write header and the quantity to be plotted ("plot")
plot_io.f90:     write (iunplot, '(a)') title
plot_io.f90:     write (iunplot, '(8i8)') nr1x, nr2x, nr3x, nr1, nr2, nr3, nat, ntyp
plot_io.f90:     write (iunplot, '(i6,2x,6f16.8)') ibrav, celldm
plot_io.f90:           write ( iunplot, * ) ( at(ipol,i),ipol=1,3 )
plot_io.f90:     write (iunplot, '(3f20.10,i6)') gcutm, dual, ecut, plot_num
plot_io.f90:     write (iunplot, '(i4,3x,a2,3x,f5.2)') &
plot_io.f90:     write (iunplot, '(i4,3x,3f15.9,3x,i2)') (na, &
plot_io.f90:     write (iunplot, '(5(1pe17.9))') (plot (ir) , ir = 1, nr1x * nr2x * nr3)
plugin_arguments.f90:!       write(0,*) "plugin_name: ", trim(arg)
plugin_arguments.f90:!  write(0,*) "use_plumed: ", use_plumed
qexml.f90:  ! This module contains some common subroutines used to read and write
qexml.f90:      CHARACTER(*),       INTENT(in)  :: action      ! ("read"|"write")
qexml.f90:      CASE ( "write", "WRITE" )
qexml.f90:      CHARACTER(*),  INTENT(in)  :: action      ! ("read"|"write")
qexml.f90:      CASE ( "write", "WRITE" )
qexml.f90:! ... write subroutines
qexml.f90:      write(gammaonly,'(I0)') gamma_only
qexml.f90:         ! ... write the G-vectors
qexml.f90:      ! open the file to write
qexml.f90:         ! write wfcs without any G-reordering
qexsd.f90:  ! This module contains some common subroutines used to read and write
qexsd.f90:         write(iun_out,"(a)") trim(str)
qexsd.f90:! ... write subroutines
qmmm.f90:    !write(stdout, *) "NEW Forces added to QM atoms (Ry / a.u.)"
qmmm.f90:    !   write(stdout, '(I5, I5, f11.7, f11.7, f11.7, f11.7)') &
qmmm.f90:    !write(stdout, *) "End of NEW forces added to QM atoms (Ry / a.u.)"
qmmm.f90:    !write(stdout, *) "Forces added to MM atoms (Ry / a.u.)"
qmmm.f90:    !   write(stdout, '(I5, f11.7, f11.7, f11.7)') &
qmmm.f90:    !write(stdout, *) "End of forces added to MM atoms (Ry / a.u.)"
radial_grids.f90:     write(6,100) k,nst
read_uspp.f90:    write(upf%generated, &
read_uspp.f90:    !    Here we write on output information on the pseudopotential 
read_uspp.f90:          write(fmt,900) 2*nang-1, 40-8*(2*nang-2)
read_uspp.f90:          write(fmt,900) 2*nang-1, 1
read_uspp.f90:    write( upf%dft, "('INDEX:',4i1)") iexch,icorr,igcx,igcc
tsvdw.f90:USE io_global,          ONLY: stdout             !print/write argument for standard output (to output file)
wannier_gw.f90:      write(stdout,*) 'MAX_NGM:', max_ngm, ngm
write_upf_v2.f90:    ! If included, write all-electron and pseudo wavefunctions
write_upf_v2.f90:      INTEGER,INTENT(IN)          :: u    ! i/o unit: write to unit u
write_upf_v2.f90:   ! Only write core orbitals in the PAW as GIPAW case
xc_rVV10.f90:       if (ionode) write(*,'(/ / A /)') "     ----------------------------------------------------------------"
xc_rVV10.f90:       if (ionode) write(*,'(A, F22.15 /)') "     Non-local correlation energy =         ", Ec_nl
xc_rVV10.f90:       if (ionode) write(*,'(A /)') "     ----------------------------------------------------------------"
xc_rVV10.f90:     write(*,'(A,F10.5,A,F10.5)') "k =  ", k, "     k_max =  ",Nr_points*dk
xc_rVV10.f90:     write(*,'(A,F10.5,A,F10.5)') "k =  ", k, "     k_max =  ",Nr_points*dk
xc_vdW_DF.f90:        write(stdout,'(/ / A)')       "     -----------------------------------------------"
xc_vdW_DF.f90:        write(stdout,'(A, F15.8, A)') "     Non-local corr. energy    =  ", Ec_nl, " Ry"
xc_vdW_DF.f90:        write(stdout,'(A /)')         "     -----------------------------------------------"
xc_vdW_DF.f90:        write(stdout,'(/ / A)')       "     -----------------------------------------------"
xc_vdW_DF.f90:        write(stdout,'(A, F15.8, A)') "     Non-local corr. energy    =  ", Ec_nl, " Ry"
xc_vdW_DF.f90:        write(stdout,'(A /)')         "     -----------------------------------------------"
xc_vdW_DF.f90:     write(*,'(A,F10.5,A,F10.5)') "k =  ", k, "     k_max =  ",Nr_points*dk
xc_vdW_DF.f90:     write(*,'(A,F10.5,A,F10.5)') "k =  ", k, "     k_max =  ",Nr_points*dk
xml_input.f90:         CALL qexml_openfile( filename, 'write', .FALSE., ierr )
xml_input.f90:      IF ( ionode ) CALL qexml_closefile( 'write', IERR=ierr )
xml_io_base.f90:  ! ... this module contains some common subroutines used to read and write
xml_io_base.f90:      ! ... find the index of the group (pool) that will write rho
xml_io_base.f90:         !  Only one subgroup write the charge density
xml_io_base.f90:    ! ... methods to write and read wavefunctions
xml_io_base.f90:      write(gammaonly,'(I0)') gamma_only
xml_io_base.f90:            IF ( ionode ) write(60)wtmp(1:igwx) 
xml_io_base.f90:          write(*,*)'done writing evc0'
xml_io_base.f90:               !IF ( j .eq. 1)write(*,'(10f12.5)')(wtmp(i),i=1,igwx_)
xsf.f90:!   in XSF format using the FFT mesh (i.e. fast write)
